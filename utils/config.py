# the geometric config
import numpy as np

class VPM_ENV:
    rho           = 1.225
    mu            = 1.81e-5
    speedofsound  = 342.35 

class BEM_Prop:
    # based on the propeller file or set mannually
    Num_Sections = 12 
    Num_Blade    = 3
    Diameter     = 0.30
    
    # The unit of angle is degrees
    Beta         = 20.0
    Feather      = 0.0
    Pre_Cone     = 0.0
    Center       = [0.0, 0.0, 0.0]
    Normal       = [-1.0, 0.0 , 0.0]

    Radius_R, Chord_R, Twist , Rake_R, Skew_R, Sweep, t_c, CLi, Axial, Tangential \
    = None, None, None,  None, None, None, None, None, None, None
    
    section_cod  = [np.zeros((200,2)) for _ in range(Num_Sections)]                           # 12截面，200点的，x,y坐标



class VPM_Prop:
    # based on the BEM_prop or set mannually
    Rtip         = None
    Rhub         = None
    B            = None

    chorddist    = None
    twistdist    = None
    sweepdist    = None
    heightdist   = None

    airfoil_contours = [None]

    pitch        = 0.0
    CW           = False # Clock-wise rotation

    n            = 10                    # Number of blade elements per blade.
    r            = 1/5                   # Spacing between elements at the tip, divided by the spacing between elements at the root.
    rfl_n_lower  = 15                    
    rfl_n_upper  = 15
    spline_k, spline_s, spline_bc = \
    5       , 0.001   , "extrapolate"    #`spline_k` the order of the spline, `spline_s` the smoothing parameter, and `spline_bc` the boundary condition.
    rediscretize_airfoils = True         # If true, it will spline the airfoil contours and re-discretize them


    data_path    = "/home/wangchenyu/T3/FLOWUnsteady/database"
    read_polar   = "vlm.ap.read_polar" #  vlm.ap.read_polar,
                                # Use `vlm.ap.read_polar` for files that are direct
                                # outputs from XFOIL. Use `vlm.ap.read_polar2` for CSV
                                # files.

    xfoil        = False 
    alphas       = [i for i in range(-20,20,1)]
    ncrit        = 9 # Turbulence criterion for XFOIL

    ReD, Matip, altReD   = 5e5, 0.0, None # Matip will be ignore if airfoil polars are prescribed; None for nothing
    
    verbose       = True
    verbose_xfoil = False
    v_lvl         = 1
    plot_disc     = True
    save_polars   = "1_data/test/"
    figsize_factor= 2/3

class VPM_Maneuver:
    # Non-dimensional translational velocity of vehicle over time
    # the default maneuver
    # using by Main.eval(julia_Maneuver)
    @staticmethod
    def static_Maneuver():
        
        Vvehicle     = "Vvehicle(t) = zeros(3)\n "
        anglevehicle = "anglevehicle(t) = zeros(3)\n"
        RPMcontrol   = "RPMcontrol(t) = 1.0\n"
        angles       = "angles = ()\n"
        RPMs         = "RPMs = (RPMcontrol, )\n"
        
        Maneuver = Vvehicle + anglevehicle + RPMcontrol + angles + RPMs
        return Maneuver

    @staticmethod
    def Vvehicle(t):
        return np.array([0.0, 0.0, 0.0])
    
    @staticmethod
    def anglevehicle(t):
        return np.array([0.0, 0.0, 0.0])
    
    @staticmethod
    def RPMcontrol(t):
        return 1.0
    
    @staticmethod
    def angles():
        return ()
    
    @staticmethod
    def RPMs():
        return (VPM_Maneuver.RPMcontrol(0),)
    
    
    """
    Vvehicle(t) = zeros(3)
    anglevehicle(t) = zeros(3)
    RPMcontrol(t) = 1.0

    angles = ()  # Angle of each tilting system (none)
    RPMs = (RPMcontrol,)  # RPM of each rotor system
    
    """
    
    """
    maneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)
    """
    #Main.eval(maneuver)

class VPM_Simulation:
    Vref    = 0.0  # Reference velocity to scale maneuver by
    RPMref  = None # Reference RPM to scale maneuver by

    Vinit   = None #"""Vref*Vvehicle(0)""" # Initial vehicle velocity
    Winit   = None #"""pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)"""  # Initial angular velocity
    
    """simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot; Vinit=Vinit, Winit=Winit);"""    


    #Main.eval(simulation)

class VPM_Monitor:
    figs, figaxs = [], []                       # Figures generated by monitor
    
    save_path     = "2_output/test/"
    # Generate rotor monitor

    set_monitor_rotor     = True
    set_monitor_enstrophy = True
    set_monitor_Cd        = True

    """
    # Generate a rotor monitor plotting the aerodynamic performance and blade loading
    at every time step.
    # Generate monitor of flow enstrophy (numerical stability)
    # Generate monitor of SFS model coefficient Cd

    # Concatenate monitors
    monitors = uns.concatenate(monitor_rotor, monitor_enstrophy, monitor_Cd)
    """
    #Main.eval(monitor_rotor)

class VPM_Solver:
    ### the solver parameters

    nrevs           = 4                         # Number of revolutions in simulation
    nsteps_per_rev  = 36                        # Time steps per revolution

    # VPM particle shedding
    p_per_step      = 2                         # Sheds per time step
    shed_starting   = True                      # Whether to shed starting vortex
    shed_unsteady   = True                      # Whether to shed vorticity from unsteady loading
    
    lambda_vpm      = 2.124 # VPM core overlap

    # Actuator surface/line model (ASM/ALM): VLM and blade elements
    vlm_rlx         = 0.7   # VLM relaxation <-- this also applied to rotors
    vlm_vortexsheet = False            # Whether to spread surface circulation as a vortex sheet in the VPM (turns ASM on; ALM if false)
    vlm_vortexsheet_overlap     = 2.125# Overlap of particles that make the vortex sheet
    vlm_vortexsheet_distribution= "g_pressure" # Vorticity distribution of vortex sheet (`g_uniform`, `g_linear`, or `g_pressure`)
    vlm_vortexsheet_sigma_tbv   = None # Size of particles in trailing bound vortices (defaults to `sigma_vlm_surf` if not given)
    vlm_init        = False            # Initialize the first step with the VLM semi-infinite wake solution
    hubtiploss_correction = "hubtiploss_nocorrection" # vlm.hubtiploss_nocorrection Hub and tip loss correction
    # hubtiploss_correction = ((0.4, 5, 0.1, 0.05), (2, 1, 0.25, 0.05))  Hub and tip correction
    

    # Vortex particle method
    vpm_integration = "vpm.euler"       # vpm.euler or vpm.rungekutta3 VPM temporal integration scheme
    vpm_viscous     = "vpm.Inviscid"    # vpm.Inviscid() VPM viscous diffusion scheme
    vpm_SFS         = "vpm.SFS_none"    # VPM LES subfilter-scale model
    vpm_formulation = "vpm.rVPM"         # VPM formulation (`vpm.rVPM` or `vpm.cVPM`)
    vpm_kernel      = "vpm.gaussianerf"  # VPM kernel (`vpm.gaussianerf` or `vpm.winckelmans`)
    vpm_UJ          = "vpm.UJ_fmm"       # VPM particle-to-particle interaction scheme (`vpm.UJ_fmm` or `vpm.UJ_direct`)
    vpm_transposed  = True             # VPM transposed stretching scheme
    vpm_fmm         = "FMM(; p=4, ncrit=50, theta=0.4, phi=0.5)" # VPM's FMM settings
    vpm_relaxation  = "vpm.pedrizzetti"  # VPM relaxation scheme (`vpm.norelaxation`, `vpm.correctedpedrizzetti`, or `vpm.pedrizzetti`)
    vpm_surface     = True             # Whether to include surfaces in the VPM through ASM/ALM
    # Wake shedding
    wake_coupled        = True         # Couple VPM wake -> VLM solution
    shed_unsteady       = True         # Whether to shed vorticity from unsteady loading
    unsteady_shedcrit   = 0.01         # Criterion for unsteady-loading shedding
    shed_starting       = False        # Whether to shed starting vortex (only when `shed_unsteady=true`)
    shed_boundarylayer  = False        # (experimental) whether to shed vorticity from boundary layer of surfaces
    boundarylayer_prescribedCd = 0.1   # (experimental) prescribed Cd for boundary layer shedding used for wings
    boundarylayer_d     = 0.0          # (experimental) dipole width for boundary layer shedding
    omit_shedding       = []           # Indices of elements in `sim.vehicle.wake_system` on which omit shedding VPM particles


    tquit           = np.Inf       # (s) force quit the simulation at this time
    rand_RPM        = False        # (experimental) randomize RPM fluctuations
    max_static_particles = None    # Maximum number of static particles (use `nothing` to automatically estimate it)
    nsteps          = None          # Number of time steps
    ttot            = None          # (s) total simulation time
    max_particles   = None          # Maximum number of particles

    # Regularization of solvers
    sigma_rotor_surf    = None      # Rotor-on-VPM smoothing radius
    sigma_vpm_overwrite = None      # VPM smoothing radius
    sigma_vlm_solver    = -1           # Regularization of VLM solver (internal VLM-on-VLM)
    sigma_vlm_surf      = -1           # (REQUIRED!) Size of embedded particles in ASM/ALM wing surfaces (for VLM-on-VPM and VLM-on-Rotor)
    sigmafactor_vpm     = 1.0          # Core overlap of wake particles
    sigmafactor_vpmonvlm = 1           # (experimental) shrinks the particles by this factor when calculating VPM-on-VLM/Rotor induced velocities

    restart_vpmfile     = None      # VPM restart file to restart simulation
    
    # OUTPUT OPTIONS
    save_path       = None             # Where to save simulation
    run_name        = "flowunsteadysim"# Suffix of output files
    create_savepath = True             # Whether to create `save_path`
    prompt          = True             # Whether to prompt the user
    verbose         = True             # Enable verbose
    v_lvl           = 0                # Indentation level of verbose
    verbose_nsteps  = 10               # Verbose every this many steps
    raisewarnings   = True             # Whether to raise warnings
    debug           = False            # Output extra states for debugging
    nsteps_save     = 1                # Save vtks every this many steps
    nsteps_restart  = -1               # Save jlds every this many steps (restart files)
    save_code       = "\" \""          # Copy the source code in this path to `save_path`
    save_horseshoes = False            # Whether to output VLM horseshoes in VTKs
    save_static_particles = True       # Whether to save ASM/ALM embedded particles
    save_wopwopin   = True             # Generate input files for PSU-WOPWOP



